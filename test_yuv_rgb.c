// Copyright 2016 Adrien Descamps
// Distributed under BSD 3-Clause License

// This program demonstrate how to convert a YUV420p image (raw format) to RGB (ppm format)
// You need to know the source image resolution, because it is not included in a raw yuv file

#include "yuv_rgb.h"

#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

#include <x86intrin.h>

#include <libswscale/swscale.h>
#if USE_IPP
#include <ippcc.h>
#endif

// read a raw yuv image file
// raw yuv files can be generated by ffmpeg, for example, using :
//  ffmpeg -i test.png -c:v rawvideo -pix_fmt yuv420p test.yuv
// the returned image channels are contiguous, and Y stride=width, U and V stride=width/2
// memory must be freed with free
int readRawYUV(const char *filename, uint32_t width, uint32_t height, uint8_t **YUV)
{
	FILE *fp = fopen(filename, "rb");
	if(!fp)
		return 1;
	
	// check file size
	fseek(fp, 0, SEEK_END);
	uint32_t size = ftell(fp);
	if(size!=(width*height + 2*((width+1)/2)*((height+1)/2)))
	{
		fclose(fp);
		return 2;
	}
	fseek(fp, 0, SEEK_SET);
	
	*YUV = malloc(size);
	fread(*YUV, 1, size, fp);
	
	return 0;
}

// save a rgb image to ppm binary format
int savePPM(const char* filename, uint32_t width, uint32_t height, const uint8_t *RGB, size_t stride)
{
	FILE *fp = fopen(filename, "wb");
	if(!fp)
		return 1;
	
	fprintf(fp, "P6 %u %u 255\n", width, height);
	if(stride==(3*width))
	{
		fwrite(RGB, 1, 3*width*height, fp);
	}
	else
	{
		for(uint32_t i=0; i<height; ++i)
		{
			fwrite(RGB+i*stride, 1, 3*width, fp);
		}
	}
	fclose(fp);
	
	return 0;
}

int main(int argc, char **argv)
{
	if(argc<5)
	{
		printf("Usage : test <yuv image file> <image width> <image height> <output template filename>\n");
		return 1;
	}
	
	const int iteration_number = 100;
	printf("Time will be measured in each configuration for %d iterations...\n", iteration_number);
	
	const char *filename = argv[1];
	uint32_t width = atoi(argv[2]), height = atoi(argv[3]);
	const char *out = argv[4];
	char *out_filename = malloc(strlen(out)+15);
	uint8_t *YUV;
	if(readRawYUV(filename, width, height, &YUV)!=0)
	{
		printf("Error reading image file, check that the file exists and has the correct format and resolution\n");
		return 1;
	}
	uint8_t *Y = YUV, *U = YUV+width*height, *V = YUV+width*height+((width+1)/2)*((height+1)/2);
	
	uint8_t *RGB = malloc(3*width*height);
	
	//std version
	{
		clock_t t = clock();
		for(int i=0;i<iteration_number; ++i)
			yuv420_rgb24_std(width, height, Y, U, V, width, (width+1)/2, RGB, width*3, YCBCR_601);
		t = clock()-t;
		printf("Processing time (standard) : %f sec\n", ((float)t)/CLOCKS_PER_SEC);
		
		strcpy(out_filename, out);
		strcat(out_filename, "_std.ppm");
		savePPM(out_filename, width, height, RGB, 3*width);
	}
	
	//sse2 unaligned version
	{
		clock_t t = clock();
		for(int i=0;i<iteration_number; ++i)
			yuv420_rgb24_sseu(width, height, Y, U, V, width, (width+1)/2, RGB, width*3, YCBCR_601);
		t = clock()-t;
		printf("Processing time (sse2) : %f sec\n", ((float)t)/CLOCKS_PER_SEC);
		
		strcpy(out_filename, out);
		strcat(out_filename, "_sse.ppm");
		savePPM(out_filename, width, height, RGB, 3*width);
	}
	
	// ffmpeg version
	{
		
		struct SwsContext * ctx = sws_getContext(width, height, AV_PIX_FMT_YUV420P, 
			width, height, AV_PIX_FMT_RGB24, 
			0, 0, 0, 0);
		const uint8_t *const inData[3] = { Y, U, V };
		int inLinesize[3] = { width, (width+1)/2, (width+1)/2 };
		int outLinesize[1] = { 3*width};
		clock_t t = clock();
		for(int i=0;i<iteration_number; ++i)
			sws_scale(ctx, inData, inLinesize, 0, height, &RGB, outLinesize);
		t = clock()-t;
		printf("Processing time (ffmpeg) : %f sec\n", ((float)t)/CLOCKS_PER_SEC);
		
		strcpy(out_filename, out);
		strcat(out_filename, "_av.ppm");
		savePPM(out_filename, width, height, RGB, 3*width);
	}
	
	#if USE_IPP
	// ipp version
	{
		const Ipp8u* pSrc[3] = {Y,U,V};
		int srcStep[3] = {width, (width+1)/2, (width+1)/2};
		Ipp8u* pDst = RGB;
		int dstStep = 3*width;
		IppiSize imgSize = {.width=width, .height=height};
		
		clock_t t = clock();
		for(int i=0;i<iteration_number; ++i)
			ippiYCbCr420ToRGB_8u_P3C3R(pSrc, srcStep, pDst, dstStep, imgSize);
		t = clock()-t;
		printf("Processing time (ipp) : %f sec\n", ((float)t)/CLOCKS_PER_SEC);
		
		strcpy(out_filename, out);
		strcat(out_filename, "_ipp.ppm");
		savePPM(out_filename, width, height, RGB, 3*width);
	}
	#endif
	free(RGB);
	
	// now test with aligned data ...
	const size_t y_stride = width + (16-width%16)%16,
		uv_stride = (width+1)/2 + (16-((width+1)/2)%16)%16,
		rgb_stride = width*3 +(16-(3*width)%16)%16;
	const size_t y_size = y_stride*height, uv_size = uv_stride*((height+1)/2);
	uint8_t *Ya = _mm_malloc(y_size, 16);
	uint8_t *Ua = _mm_malloc(uv_size, 16);
	uint8_t *Va = _mm_malloc(uv_size, 16);
	for(unsigned int i=0; i<height; ++i)
	{
		memcpy(Ya+i*y_stride, Y+i*width, width);
		if((i%2)==0)
		{
			memcpy(Ua+(i/2)*uv_stride, U+(i/2)*((width+1)/2), (width+1)/2);
			memcpy(Va+(i/2)*uv_stride, V+(i/2)*((width+1)/2), (width+1)/2);
		}
	}
	
	RGB = _mm_malloc(3*rgb_stride*height, 16);
	
	//sse2 aligned version
	{
		clock_t t = clock();
		for(int i=0;i<iteration_number; ++i)
			yuv420_rgb24_sse(width, height, Ya, Ua, Va, y_stride, uv_stride, RGB, rgb_stride, YCBCR_601);
		t = clock()-t;
		printf("Processing time (sse2 aligned) : %f sec\n", ((float)t)/CLOCKS_PER_SEC);
		
		strcpy(out_filename, out);
		strcat(out_filename, "_sse_a.ppm");
		savePPM(out_filename, width, height, RGB, rgb_stride);
	}
	
	// ffmpeg aligned version
	{
		struct SwsContext * ctx = sws_getContext(width, height, AV_PIX_FMT_YUV420P, 
			width, height, AV_PIX_FMT_RGB24, 
			0, 0, 0, 0);
		const uint8_t *const inData[3] = { Ya, Ua, Va };
		int inLinesize[3] = { y_stride, uv_stride, uv_stride};
		int outLinesize[1] = {rgb_stride};
		clock_t t = clock();
		for(int i=0;i<iteration_number; ++i)
			sws_scale(ctx, inData, inLinesize, 0, height, &RGB, outLinesize);
		t = clock()-t;
		printf("Processing time (ffmpeg aligned) : %f sec\n", ((float)t)/CLOCKS_PER_SEC);
		
		strcpy(out_filename, out);
		strcat(out_filename, "_av_a.ppm");
		savePPM(out_filename, width, height, RGB, rgb_stride);
	}
	
	#if USE_IPP
	// ipp aligned version
	{
		const Ipp8u* pSrc[3] = {Ya,Ua,Va};
		int srcStep[3] = {y_stride, uv_stride, uv_stride};
		Ipp8u* pDst = RGB;
		int dstStep = rgb_stride;
		IppiSize imgSize = {.width=width, .height=height};
		
		clock_t t = clock();
		for(int i=0;i<iteration_number; ++i)
			ippiYCbCr420ToRGB_8u_P3C3R(pSrc, srcStep, pDst, dstStep, imgSize);
		t = clock()-t;
		printf("Processing time (ipp aligned) : %f sec\n", ((float)t)/CLOCKS_PER_SEC);
		
		strcpy(out_filename, out);
		strcat(out_filename, "_ipp_a.ppm");
		savePPM(out_filename, width, height, RGB, rgb_stride);
	}
	#endif
	
	_mm_free(RGB);
	_mm_free(Va);
	_mm_free(Ua);
	_mm_free(Ya);
	
	free(YUV);
	free(out_filename);
	
	return 0;
}

